# インデックスを設定できる

## 1. インデックス設定前

employees データベースの employees テーブルに対して、誕生日が1961年8月3日のレコードを取得してください。その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測してください。

```sql
mysql> SELECT * FROM employees WHERE birth_date = '1961-08-03';
```

実行結果
-> Filter: (employees.birth_date = DATE'1961-08-03')  (cost=30170 rows=29938) (actual time=16.8..139 rows=67 loops=1)  
    -> Table scan on employees  (cost=30170 rows=299379) (actual time=0.0885..113 rows=300024 loops=1)

## 2. インデックスの作成

employees データベースの employees テーブルの birth_date カラムにインデックスを作成してください。
```sql
mysql> CREATE INDEX birth_date_index ON employees(birth_date);
```

## 3. インデックスの確認

employees データベースの employees テーブルのインデックスを確認し、インデックスが作成されていることを確認してください。
```sql
mysql> show indexes from employees;
```

実行結果
-> Index lookup on employees using birth_date_index (birth_date=DATE'1961-08-03')  (cost=23.4 rows=67) (actual time=1.68..1.7 rows=67 loops=1)

インデックスを貼る前
実行結果
-> Filter: (employees.birth_date = DATE'1961-08-03')  (cost=30170 rows=29938) (actual time=16.8..139 rows=67 loops=1)  
    -> Table scan on employees  (cost=30170 rows=299379) (actual time=0.0885..113 rows=300024 loops=1)

## 4. インデックスの効果の確認

1と同じクエリを実行してください。その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測し、実行が高速化されていることを確認してください。
```sql
mysql> EXPLAIN ANALYZE SELECT * FROM employees WHERE birth_date = '1961-08-03';
```

## 5. インデックスの説明

インデックスを貼ることでクエリが高速化された理由をデータベース初心者にわかるように説明してください。
```
↓最後にまとめて解説
```

## 6. インデックスの削除

作成したインデックスを削除してください。
```sql
mysql> DROP INDEX birth_date_index ON employees;
```

## 7. ベストプラクティス

インデックスは作成すればするほどよいというものではありません。必要な場合のみ作成することが重要です。

インデックス作成のベストプラクティスについて調べ、どのような方針でインデックスを貼ると良いかまとめてください。



例えば、以下のクエリを実行したとき、
```sql
mysql> SELECT * FROM employees WHERE birth_date = '1961-08-03';
```
MySQLは内部でこのような動作をする。
1. `employees`テーブル内のレコードをすべて読み出す。
2. `birth_date`フィールドを調べ、文字列'1961-08-03'に一致するかどうかを比較する。
すべてのレコードを読み出すため、レコードの数が増えれば増えるほど必要な処理が増えることになる。
テーブルのレコード数nに対して、特定のレコードを見つけるための検索に要する処理量（オーダー）がレコードnに比例することを、**O(n)問題**という。

インデックスが存在するとき、テーブルを全検索するのではなく、インデックスに対して検索を実行する。その後、インデックスから取得した情報に基づいて必要なレコードを探しに行くというような処理になる。
例えば、'1961-08-03'が何行目にあるかというインデックス（目次）を作成しておき、その後テーブルを検索しにいくときには、インデックスから情報を取得するので全件探さなくても良くなる。

インデックスがあるとき
```
'1961-08-03'は、5行目と、10行目にある。（インデックスを作っておくので容量を必要とする）
↓
'1961-08-03'を検索するクエリが飛んできた。
↓
'1961-08-03'は5行目と10行目にあるから、5行目と10行目を返そう。
```

インデックスがないとき
```
'1961-08-03'を検索するクエリが飛んできた。
↓
どこにあるかわからないので、テーブルを全件探す。（時間がかかる）
↓
'1961-08-03'は5行目と10行目にあるから、5行目と10行目を返そう。
```

インデックスを使用することで、検索の性能は向上するが、容量が犠牲になる。
インデックスがなければ、MySQLはテーブル内のすべての行を調べなければならない。
一方でMySQLは、インデックスの値を別個のリストで保守し、データに変化があるたびにインデックスを更新し続ける必要がある。
テーブルのすべてのカラムにインデックスをつけると書き込みの速度が低下するし、データを保存するために必要な容量が増えてしまう。


テーブルのクエリが遅くなったり、インデックスの問題が発生するなど、しばらくみなかったような問題が発生した場合、

```sql
show indexes from テーブル名;
```

このコマンドでインデックス情報を取得する必要がある。
以下のような情報が取得できる。

|Table|テーブル名|
|:----|:----|
|Non_unique|もしインデックスが複製を含む事ができなければ0、もしできるなら1。|
|Key_name|インデックス名|
|Seq_in_index|1から始まる、インデックス内のカラム シーケンス番号|
|Column_name|カラム名|
|Collation|カラムがインデックス内でどのようにソートされるか。MySQL では、これは値 ‘A’ (昇順)か NULL (格納されない)を持つ事ができる。|
|Cardinality|インデックス内の固有値数の見積もり。ANALYZE TABLE か myisamchk -a を起動させる事で更新される。濃度が高ければ、その分 MySQL が接合を行う時にインデックスを利用する可能性は高くなる。※下記に別途説明。|
|Sub_part|もしカラムが部分的にだけインデックスされていた時のインデックスされる文字数。カラム全体がインデックスされていた時は NULL。|
|Packed|キーがどのようにパックされるのかを指示する。そうでなければ NULL。|
|Null|もしカラムが NULL を含んでいたら、YES。そうでなければ、NO。|
|Index_type|使用されるインデックス方法(BTREE、FULLTEXT、HASH、RTREE)|
|Comment|様々な意見|


レコードの数が多いとき、もしくは多くなることが想定されるとき、
さらに頻繁にテーブルからレコードを取得するとき、
インデックスを貼っておくことで、高速に取得することができる。

そうでない場合は、インデックスを貼っても容量を使うだけなので必要ない。


インデックスを使用する場合、以下の項目が使用対象となる。
- WHEREやJOINで使用されるかどうか
- レコード件数が1万件を超えるかどうか
- 外部キーかどうか
- カーディナリティが20以上かどうか
- カラムに対してSQL関数が使われているかどうか